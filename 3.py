def search_insert(nums, target) -> int:
    # ТУПА БИНАРНЫЙ ПОИСК ДЛЯ ПОИСКА МЕСТА ВСТАВКИ
    low, high = 0, len(nums)
    if len(nums) == 0:
        return 0
    while low < high:
        mid = (low + high) // 2
        if target > nums[mid][0]:
            low = mid + 1
        else:
            high = mid
    return low


# Целесообразно исползовать не самописную, а из библиотеки
class Queue:
    # Очередь с приоритеным включением. То есть просто сортируем в потоке :)
    def __init__(self):
        self.queue = []

    def push(self, element):
        self.queue.insert(search_insert(self.queue, element))  # Как бы мощно сортируем в потоке

    def get(self):
        return self.queue.pop(-1)  # Возвращаем последний элемент, хихи хаха


metro_map = {
    # Станция: [(сколько времени, станция), (сколько времени, станция)]
    # Начинаю с желткой и вправо, если есть переход на другую ветку, то расстояние считаю за 0 минут)
    # Расстояние == время чтобы приехать. Информация с карты Артемия Лебедева https://metrorus.ru/moscow-metro/
    # Необходимо брать наименьшее время которое показывает до станции
    'Рассказовка': [(5, 'Новопеределкино')],
    'Новопеределкино': [(5, 'Бобровское шоссе'), (5, 'Рассказовка')],
    'Бобровское шоссе': [(5, 'Солнцево'), (5, "Новопеределкино")],
    'Солнцево': [(5, 'Бобровское шоссе'), (5, "Говорово")],  # Продолжите кто-то, я устал

}
